# Binary search tree       
## 新增insert           
默認一開始傳進來的值為root，根據左邊的子節點比父節點小，右邊的子節點比父節點大的原則         
注意：相等時看是取小於等於還是大於等於                
在插入時，要一層一層的往下比較          
具體流程：          
1.若一開始是空树，则将傳進來的值s作为根节点(root)插入，否则：           
2.若s小于等於binary search tree的根节点之值，则把s所指节点插入到左子树中，否则：           
3.把s所指节点插入到右子树中。（新插入节点总是叶子节点）         

## 刪除delete        
注意：採取最小變動的原則！！！        
可歸納為三種情況：刪除撒旦，弗利扎，西魯          
1.刪除撒旦（995）            
若刪去值p為最下層子節點，則它無子樹。刪除不會破壞整個樹的結構，修改雙親節點的指針即可                 
![image](https://github.com/wangshuti/DSA/blob/master/image/delete1.png)                 
2.刪除弗利扎（79）                  
若p節點只有左子樹（PL）或右子樹（PR)，此時只要令PL或PR直接成為其母樹的節點的子樹就可           
![image](https://github.com/wangshuti/DSA/blob/master/image/delete2.png)                         
3.刪除西魯（666）         
若p左子樹與右子樹均不為空，在刪p之後，要保持最小變動，則較為複雜        
![image](https://github.com/wangshuti/DSA/blob/master/image/delete3.png)                      
由於西魯有兩個child，若直接刪除西魯的資料，要牽動的node較多。變通的祕訣就是「找替身」。           
原本要刪西魯，但是實際上是釋放西魯的「Successor(達爾)」的記憶體位置(或是「Predecessor(16號)」的記憶體位置)，最後再把「Successor(達爾)」(或是「Predecessor(16號)」)的資料放回到西魯的記憶體位置上，又因為BST的特徵，所有「具有兩個child」的node的Successor或是Predecessor一定是leaf node或是只有一個child，如此，便回到如同撒旦與弗力札「至多只有一個child」的情境。                     
稍微驗證一下「具有兩個child的node的Successor或是Predecessor一定是leaf node或是只有一個child」，若某個node有兩個child：
Successor找的是「right subtree中Key最小的node」；            
Predecessor找的是「left subtree中Key最大的node」；                
因此Successor和Predecessor必定不會同時也有兩個child              
現欲刪除西魯，就去找西魯的Successor(達爾)當做替身，因為達爾沒有child，其刪除方法便如同上述刪除撒旦的方法        
![image](https://github.com/wangshuti/DSA/blob/master/image/delete4.png) 

## 查詢search                          
會有兩種情況：                  
1.搜尋的值key找到匹配的值，搜尋成功                        
2.搜尋的值key最後傳到NULL，則搜尋失敗                 
範例：                   
若現在要從BST中搜尋基紐隊長，便以基紐隊長（627）進入BST。 進入BST後，便把用來移動的Current指向root           
![image](https://github.com/wangshuti/DSA/blob/master/image/s1.png)            
接著將KEY(627)和比克(root)的戰鬥力(513)比較，結果是基紐隊長戰勝，因此，基紐隊長如果在BST裡面，應該會長在比克的right subtree裡面，於是便將Current往比克的right child(達爾)移動              
![image](https://github.com/wangshuti/DSA/blob/master/image/s2.png)       
將Current移動到達爾之後，再將KEY(627)與達爾的戰鬥力(524)比較，結果仍然是基紐隊長大，因此步驟同上，繼續將Current往達爾的right child(弗力札)移動
![image](https://github.com/wangshuti/DSA/blob/master/image/s3.png)            
將Current移動到弗力札之後，再將KEY(627)與弗力札的戰鬥力(709)比較，結果是弗力札略勝，於是便往弗力札的left child尋找基紐隊長         
![image](https://github.com/wangshuti/DSA/blob/master/image/s4.png)                  
此時，Current的Key(627)與傳送進Search()的KEY(627)相同，便確認Current即為基紐隊長，於是跳出while迴圈，並傳回Current。        
宣告搜尋成功。        
